\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage[margin=1in]{geometry} 
\usepackage{scrextend}
\usepackage{relsize}
\usepackage{sectsty}

\title{%
  Sistemi Operativi \\
  \large Riassunto delle lezioni di Laboratorio A.A. 2018/2019}

\author{Matteo Franzil}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Comandi Bash}

La seguente è una lista, non esaustiva, dei comandi visti a lezione per l'uso della shell Bash.

\subsection{Comandi}
\begin{itemize}
    \item\verb|free| $\rightarrow$ memoria libera
    \item\verb|pwd| $\rightarrow$ cartella corrente
    \item\verb|df| $\rightarrow$ partizioni
    \item\verb|dirname| $\rightarrow$ ottiene il nome della cartella di un dato file
\end{itemize}

\subsection{Piping}
\begin{itemize}
    \item\verb|;| $\rightarrow$ esecuzione in sequenza
    \item\verb=&& ||= $\rightarrow$ esecuzione in sequenza con corto circuito
    \item\verb=|= $\rightarrow$ piping classico
    \item\verb|>| $\rightarrow$ redirect su file classico
    \item\verb|1>| $\rightarrow$ redirect di \verb|stdout|
    \item\verb|2>| $\rightarrow$ redirect di \verb|stderr|
\end{itemize}

\subsection{Intestazioni}
\begin{itemize}
    \item\verb|#! /bin/bash| $\rightarrow$ intestazione
    \item\verb|#Script "Hello World"| $\rightarrow$ intestazione nominativa
\end{itemize}

\subsection{Scripting}
\begin{itemize}
    \item\verb|var=VALORE| $\rightarrow$ assegnazione (sono sempre stringhe)
    \item\verb|${var}| $\rightarrow$ stampa (con eventuale esecuzione)
    \item\verb|$@| $\rightarrow$ equivalente ad \verb|argv|
    \item\verb|$#| $\rightarrow$ equivalente ad \verb|argc|
    \item\verb|$1|, \verb|$2|, \verb|$3|, \verb|$n| $\rightarrow$ i primi 9 parametri passati
    \item\verb|shift| $\rightarrow$ cestina il primo argomento nella lista
    \item\verb|" ... "| $\rightarrow$ crea un comando / stringa interpolando variabili
    \item\verb|$(( ... ))| $\rightarrow$ contengono espressioni aritmetiche: se all'interno uso una \verb|$var|, viene sostituita come fosse una macro, se uso il singolo contenuto di \verb|var| allora viene inserito il valore come avesse le parentesi.
    \item\verb|bc| $\rightarrow$ comando che supporta il piping in entrata, per eseguire operazioni in float
    \item\verb|# Commenti| $\rightarrow$ commento classico di singola riga
    \item\verb|$?| $\rightarrow$ valore di ritorno globale, usato dagli script (tipo return 0 in C): ha significato booleano (\textbf{0} niente errori, arriva fino a \textbf{256})
\end{itemize}

\subsection{Booleani}
\begin{itemize}
    \item\verb|test ...| $\rightarrow$ si aspetta un espressione booleana, e internamente modifica il registro booleano visto prima:
    \item\verb|-eq, -ne, -lt, -gt| $\rightarrow$ operandi booleani utilizzati
    \item\verb|[ ... ]| $\rightarrow$ sintassi di testing alternativa (gli spazi sono importanti!); attenzione che le parentesi quadrate sono considerate come ultimo comando eseguito
    \item\verb|[[ ... ]]| $\rightarrow$ raggruppamento di espressioni booleani per utilizzare operatori comuni (>, < ...)-
    \item\verb| -f (file) -d (directory)| $\rightarrow$ verificano l'esistenza di un dato file/cartella.
\end{itemize}

\subsection{Cicli}
\begin{itemize}
    \item\verb|if [ ... ]; then ... ; else ...; fi| $\rightarrow$ costrutto if standard
          % Utilizzo = al posto di un pipe per evitare conflitti inutili
    \item\verb=case $var in; a|b) ... ;; c) ... ;; esac= $\rightarrow$ costrutto switch standard
    \item\verb|for (( init ; case; step )); do; ...; done| $\rightarrow$ costrutto for standard
    \item\verb|until [[ ... ]] ; ...; done| $\rightarrow$ while negato
    \item\verb|while [[ ... ]] ; ...; done| $\rightarrow$ while standard
\end{itemize}

\subsection{Funzioni}
\begin{itemize}
    \item\verb|func() { ... }| $\rightarrow$ accedibile come fossero degli script (\verb|func arg1 ... argn|)
\end{itemize}

\subsection{Varie}
\begin{itemize}
    \item\verb|$( ... )| $\rightarrow$ sottoshell che esegue comandi in un processo separato
    \item\verb|BASH_SOURCE[0]| $\rightarrow$ contiene il nome dello script in esecuzione
    \item\verb|exit n| $\rightarrow$ uscita con codice d'errore
    \item\verb|1> 2> ... n>| $\rightarrow$ redirezionamento dei diversi canali sui file, come visto prima (1 = stdout, 2 = stderr); è possibile redirezionare stderr su stdout e viceversa tramite il comando \verb|2>&1|, oppure mettendo tutto su file: \verb|1>output 2>&1|. L'ordine in cui vengono interpretati i redirect sono da destra a sinistra.
\end{itemize}

\section{Make}

\subsection{Introduzione}

Make è un tool utilizzato per automatizzare processi all'interno di sistemi Unix. Viene principalmente usato per automatizzare la compilazione dei file.

I Makefile sono composti da regole, composte da un \textbf{identificativo} (o nome) e da una \textbf{ricetta} (una serie di comandi indentati con una tabulazione \verb|\t| rispetto al nome della ricetta):

\begin{verbatim}
regola:
    echo "Ciao"
\end{verbatim}

I file vengono poi eseguiti tramite il comando \verb|make -f nome_file.makefile|. Notare come i comandi vengono anche stampati su \verb|stdout| oltre a essere eseguiti. Questa funzionalità può essere sfruttata per stampare a video anche i procedimenti che vengono eseguiti dal file, ma può risultare fastidioso: si può quindi inserire una chiocciola \verb|@| che impedisce la stampa del comando.

Il nome del file è opzionale e se non presente viene cercato all'interna della cartella corrente un nome corrispondente a \verb|Makefile|.

In ogni ricetta, ogni riga è trattata singolarmente come un singolo processo, caricando la giusta cartella di lavoro di volta in volta. Bisogna quindi fare attenzione all'uso di \verb|cd|.

All'inizio di ogni regola, si può inoltre specificare una o più \textit{dipendenze} che devono essere rispettate prima di avviare la regola corrispondente. A tal scopo si usa generalmente dare il nome del file che verrà generato alla regola stessa, se la regola ne genera qualcuno:

\begin{verbatim}
file.cc: dipendenza1 dipendenza2... 
    comandi per generare file.cc...
\end{verbatim}

In tutti gli altri casi si parla di \textit{pseudo-regole} ed il nome può essere attribuito di fantasia.

\subsection{Definizione di macro}

All'interno dei makefile si possono definire delle macro, che possono essere utilizzate con una sintassi analoga a bash. Ciò risulta problematico in quanto \verb|$| è interpretato prima da Makefile e poi da Bash.

\begin{verbatim}
MACRO1=Pippo
main:
    @echo Hello $(MACRO1)
\end{verbatim}

Le macro possono inoltre essere sovrascritte al momento dell'avvio di \verb|MAKE| con la medesima sintassi (ma è necessario che la macro stessa sia definita all'interno del file).

Con la sintassi \verb|$(...)| è possibile accedere a una sotto-shell, analoga a quella di Bash, per eseguire comandi all'interno del Makefile stesso. In questo sotto-comando tutti gli \verb|\n| vengono tramutati in spazi.

\section{gcc}

\subsection{Introduzione}

\verb|gcc| è un compilatore multi source/target per compilare i file sorgenti C. Viene utilizzato in combinazione con Make per compilare velocemente più sorgenti.

\subsection{Flag}
\begin{itemize}
    \item\verb|gcc main.c -S| $\rightarrow$ compila in codice Assembly
    \item\verb|gcc main.c -E| $\rightarrow$ esegue solo il preprocessore
    \item\verb|gcc main.c -c| $\rightarrow$ compila senza linkare
    \item\verb|gcc main.c -o| $\rightarrow$ genera i file oggetto binari
    \item\verb|gcc main.c -g| $\rightarrow$ compilazione con mapping per \verb|gdb|
    \item\verb|gcc main.c -DNOME=VAL| $\rightarrow$ compilazione con definizione di macro NOME=VAL
\end{itemize}

\subsection{gdb}

\verb|gdb| è un debugger usato in combinazione con \verb|gcc|. In questo ambiente controllato, possiamo tenere traccia dello stato dell'esecuzione del programma mappando opportunamente le variabili (in quanto i nomi vengono persi durante la compilazione).

Per iniziare, si usa il comando \verb|run| nella shell interattiva che viene presentata da \verb|gdb|.

Punto centrale del debugging è il \textbf{breakpoint}; si tratta di un punto, indicato manualmente con \verb|break *|, che causerà l'interruzione dell'esecuzione del programma una volta raggiunto. A questo punto è possibile o usare \verb|step <count>| e \verb|next <count>| per fare uno o più step generici o principali, oppure interferire volontariamente in maniera più o meno pesante, ad esempio usando \verb|print| per ottenere i valori delle variabili oppure \verb|set variable vname=value| per modificare il valore. Si può infine continuare l'esecuzione con \verb|continue|.

\section{C}

\subsection{Introduzione}

Il lingaggio C è un linguaggio di "basso livello", alla base dei sistemi Unix e dotato di una struttura minimale e ben definita, che velocizza le prestazioni omettendo funzioni di alto livello presenti invece in altri linguaggi.

Prima della compilazione vi è un \textit{pre-processore} il cui compito è interpretare le direttive e gli alias definiti all'inizio del file (tramite l'apposito carattere \verb|#|), generando il cosiddetto file "sorgente direttivo". Le direttive sono varie, seguono le principali:

\begin{itemize}
    \item\verb|#include <lib>| $\rightarrow$ inclusione di codici libreria
    \item\verb|#include "file"| $\rightarrow$ inclusione di file \verb|.h| esterni
    \item\verb|#define NOME TESTO| $\rightarrow$ macro
    \item\verb|#define FUNC(X,Y) (X) (Y)| $\rightarrow$ macro con funzioni
    \item\verb|#if|, \verb|#ifdef NOME|, \verb|#ifndef NOME|, \verb|#else|, \verb|endif| $\rightarrow$ controlli
\end{itemize}

Il linguaggio viene quindi compilato e analizzato una sola volta: prima viene trasformato in codice intermedio (Assembly), poi in file oggetto \verb|.o| e infine linkato ai file libreria e trasformato in linguaggio macchina \verb|.out|.

\subsection{Sintassi}

\begin{itemize}
    \item\verb|int printf(const char *format, …)| $\rightarrow$ stampa con formattazione:\\ \verb|%[flags][width][.precision][length]specifier|; alcuni specifier sono:
        \subitem\verb|%c| $\rightarrow$ \verb|char|
        \subitem\verb|%d| $\rightarrow$ \verb|int|
        \subitem\verb|%li| $\rightarrow$ \verb|long|
        \subitem\verb|%s| $\rightarrow$ \verb|char*| (ovvero una stringa)
        \subitem\verb|%p| $\rightarrow$ locazione di memoria
    \item Si può ovviare alla mancanza dei booleani tramite un apposita macro: \verb|#define BOOL char;| \verb|#define FALSE 0;| \verb|#define TRUE 1;|. Si noti che questa variabile può comunque, analogamente a un char, contenere valori fino a 255; è quindi cura del programmatore utilizzarla in maniera corretta e non confusionaria.
\end{itemize}

\subsection{Organizzazione della memoria}

Data l'immagine del processo in memoria, partendo dall'indirizzo più basso, troviamo:
\begin{itemize}
    \item OS Kernel
    \item Text segment: istruzioni della CPU
    \item Data segment: variabili globali
    \item BSS: variabili non inizializzate
    \item Heap e stack: allocazione dinamica automatica e personalizzata
\end{itemize}

In C, non c'è garbage collection e la memoria allocata dinamicamente va esplicitamente deallocata per evitare fastidiosi memory leak. AL momento dell'allocazione in memoria, distinguiamo tra \textbf{variabili statiche}, corrispondenti alle variabili globali dichiarate all'inizio, \textbf{variabili dinamiche}, ovvero le variabili dichiarate con \verb|new| e con puntatori e che devono essere esplicitamente deallocate, e \textbf{variabili auomatiche}, locali a una funzione.

\subsection{Stringhe, puntatori, tipi}

In C, una \textbf{stringa} è un array di \verb|char| che termina con uno \verb|\0|, detto \textit{terminatore di sequenza}. Per poter lavorare con le stringhe è necessario utilizzare delle opportune funzioni che le trattano come array.

Un \textbf{puntatore} è una variabile che punta a una certa casella di memoria. \verb|int* a| rappresenta un puntatore (non inizializzato) a una variabile di tipo \verb|int|. L'asterisco viene inoltre utilizzato per accedere alla locazione \verb|*a|; \verb|&a| rappresenta invece la locazione di memoria puntata in esadecimale.

Importante è la notazione: infatti il simbolo \verb|*| si lega al nome della variabile e non al tipo, per cui scrivere \verb|int* a, b| definirà una variabile \verb|a| di tipo puntatore a int e \verb|b| di tipo int, e non due puntatori come si potrebbe pensare.

In C è inoltre possibile costruire tipi di dati derivati e rinominarne altri con i costrutti \verb|struct| e \verb|typedef|. La prima permette di creare "tipi aggregati", in maniera analoga a una classe in un linguaggio Object-Oriented; la seconda permette di ridefinire, in maniera analoga a una macro, un certo tipo di dato oppure una struct con un nuovo nome.

Esiste infine \verb|union| che funziona in maniera simile, ma i campi sono mutualmente esclusivi e condividono lo spazio d'indirizzamento: assegnare uno causa la sovrascrittura degli altri campi.

\subsection{Allocazione}

All'interno della libreria \verb|stdlib.h| abbiamo svariate primite per l'allocazione e deallocazione di memoria, tra cui:

\begin{itemize}
    \item\verb|sizeof(item)| che restiuisce la quantità di memoria occupata da \verb|item|
    \item\verb|malloc(size)| che alloca \verb|size| quantità di memoria
    \item\verb|calloc(num, size)| che alloca spazio per \verb|num| oggetti di dimensione \verb|size|
    \item\verb|realloc(ptr, newsize)| che rialloca la memoria puntata da \verb|ptr| con la nuova dimensione \verb|newsize|
    \item \verb|free(ptr)| che libera la memoria occupata da \verb|ptr|
\end{itemize}

Un esempio di utilizzo:
\begin{verbatim}
    int* a;
    a = (int*) malloc(sizeof(int) * 100);
\end{verbatim}

\section{Processi}

Per la teoria riguardante i processi, consultare gli appunti di teoria del corso.

La seguente è una lista, non esaustiva, di comandi utili alla gestione dei processi di sistema Unix tramite Bash.

\begin{itemize}
    \item \verb|command&| $\rightarrow$ lancia un processo in background, restituendo il suo PID
    \item \verb|ps| $\rightarrow$ elenca i processi attivi su sistema
    \item \verb|ps -o pid,ppid,pgid,sid,uid,euid| $\rightarrow$ elenca i processi attivi con informazioni extra
\end{itemize}

La seguente è una lista degli identificatori di processo:

\begin{itemize}
    \item \verb|PID| $\rightarrow$ attributo di identificazione univoco per istante temporale
    \item \verb|PPID| $\rightarrow$ id del processo genitore
    \item \verb|PGID| $\rightarrow$ id di un gruppo di processi, che possono collaborare in maniera stretta tra loro; al momento della creazione i figli entrano nel gruppo di un genitore
    \item \verb|SID| $\rightarrow$ insieme di gruppi di processi; alla creazione un processo è associato alla sessione del padre
    \item \verb|RUID, EUID| $\rightarrow$ rispettivamente l'id utente del creatore ed esecutore del processo
\end{itemize}

\section{Architettura}

\subsection{Introduzione}

L'architettura di sistema Unix ha come elemento centrale il kernel, che si occupa della gestione delle risorse (ulteriori informazioni nella parte di teoria del corso). Al momento dell'avvio, il kernel verifica lo stato dell'hardware, monta la partizione di sistema in modalità di sola lettura e lancia \textit{init}, ovvero il primissimo processo (\verb|/sbin/init|). A partire da \textit{init} vengono fatti partire tutti i processi che si occupano dell'avvio del sistema, sia in maniera diretta con \verb|fork| sia indiretta con \verb|exec|.

I programmi utente, per accedere all'hardware, devono per forza passare per il kernel (vedi parte del \textit{context switch} nella parte di teoria). Il kernel rimane l'unica risorsa di sistema ad avere accesso privilegiato a tutte le componenti dell'hardware.

Ogni programma è all'oscuro delle astrazioni fornite dal sistema operativo e crede di avere la CPU tutta per sè, e non gli viene permesso di disturbare le azioni degli altri processi. Grazie a ciò i processi Unix sono considerati particolarmente stabili.

\subsection{File system}

Il sistema Unix fornisce due interfacce per l'accesso ai file da parte dei processi: gli \textit{stream} e i \textit{file descriptor}. 

\subsubsection{Stream}

Negli \textit{stream}, un file è descritto come puntatore a un tipo file (\verb|File*|): una volta creato un oggetto di questo tipo possiamo usare strumenti per la lettura, la scrittura, con relativa formattazione e buffering, che forniscono un livello di astrazione in più rispetto a quanto fornito dal kernel.

\subsubsection{File descriptor}

Nei \textit{file descriptor}, ogni file è associato a un intero (\verb|int|) che punta alla rispettiva locazione della tabella di file. In questo caso vi è un buffer specifico per la lettura e la scrittura, di dimensione arbitraria ma fissata. Per accedere al buffer si fa uso di apposite system call, ovvero \verb|open, read, write, lseek, close|. Queste permettono un controllo maggiore sul file ma complicano la scrittura di codice. 

Da notare come ogni processo Unix possiede, alla nascita, tre file descriptor \verb|0, 1, 2| che corrispondono a \verb|stdin|, \verb|stdout| e \verb|stderr|. Tutti i file che vengono apertitramite file descriptor useranno interi successivi a questi (con un limite di circa 100). 

Al momento dell'apertura di un file con \verb|open|, la system call localizza l'i-node del file (ovvero la struttura dati appartenente al file system che contiene informazioni sul file come dimensioni, permessi, etc...) e ne inserisce un puntatore nella \textit{tabella dei file aperti dal processo} assegnandogli un intero, in modo da potervi rapidamente accedere.

A livello kernel, inoltre, vi sono inoltre due tabelle globali. Una è la \textit{tabella dei file attivi} che contiene una copia dell'i-node di tutti i file che sono stati aperti da tutti i processi, l'altra è la \textit{tabella dei file aperti del sistema} che invece contiene riferimenti a tutti i file che non hanno ancora terminato operazioni di lettura o scrittura. Ogni entry contiene il puntatore I/O della posizione e un puntatore all'i-node della tabella dei file attivi. Se un file viene aperto da pià processi, avrà elementi distinti in questa tabella.

\end{document}
