\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage[margin=1in]{geometry} 
\usepackage{scrextend}
\usepackage{relsize}
\usepackage{sectsty}

\title{%
  Sistemi Operativi \\
  \large Riassunto delle lezioni di Laboratorio A.A. 2018/2019}

\author{Matteo Franzil}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Comandi Bash}

La seguente è una lista, non esaustiva, dei comandi visti a lezione per l'uso della shell Bash.

\subsection{Comandi}
\begin{itemize}
    \item\verb|free| $\rightarrow$ memoria libera
    \item\verb|pwd| $\rightarrow$ cartella corrente
    \item\verb|df| $\rightarrow$ partizioni
    \item\verb|dirname| $\rightarrow$ ottiene il nome della cartella di un dato file
\end{itemize}

\subsection{Piping}
\begin{itemize}
    \item\verb|;| $\rightarrow$ esecuzione in sequenza
    \item\verb=&& ||= $\rightarrow$ esecuzione in sequenza con corto circuito
    \item\verb=|= $\rightarrow$ piping classico
    \item\verb|>| $\rightarrow$ redirect su file classico
    \item\verb|1>| $\rightarrow$ redirect di \verb|stdout|
    \item\verb|2>| $\rightarrow$ redirect di \verb|stderr|
\end{itemize}

\subsection{Intestazioni}
\begin{itemize}
    \item\verb|#! /bin/bash| $\rightarrow$ intestazione
    \item\verb|#Script "Hello World"| $\rightarrow$ intestazione nominativa
\end{itemize}

\subsection{Scripting}
\begin{itemize}
    \item\verb|var=VALORE| $\rightarrow$ assegnazione (sono sempre stringhe)
    \item\verb|${var}| $\rightarrow$ stampa (con eventuale esecuzione)
    \item\verb|$@| $\rightarrow$ equivalente ad \verb|argv|
    \item\verb|$#| $\rightarrow$ equivalente ad \verb|argc|
    \item\verb|$1|, \verb|$2|, \verb|$3|, \verb|$n| $\rightarrow$ i primi 9 parametri passati
    \item\verb|shift| $\rightarrow$ cestina il primo argomento nella lista
    \item\verb|" ... "| $\rightarrow$ crea un comando / stringa interpolando variabili
    \item\verb|$(( ... ))| $\rightarrow$ contengono espressioni aritmetiche: se all'interno uso una \verb|$var|, viene sostituita come fosse una macro, se uso il singolo contenuto di \verb|var| allora viene inserito il valore come avesse le parentesi.
    \item\verb|bc| $\rightarrow$ comando che supporta il piping in entrata, per eseguire operazioni in float
    \item\verb|# Commenti| $\rightarrow$ commento classico di singola riga
    \item\verb|$?| $\rightarrow$ valore di ritorno globale, usato dagli script (tipo return 0 in C): ha significato booleano (\textbf{0} niente errori, arriva fino a \textbf{256})
\end{itemize}

\subsection{Booleani}
\begin{itemize}
    \item\verb|test ...| $\rightarrow$ si aspetta un espressione booleana, e internamente modifica il registro booleano visto prima:
    \item\verb|-eq, -ne, -lt, -gt| $\rightarrow$ operandi booleani utilizzati
    \item\verb|[ ... ]| $\rightarrow$ sintassi di testing alternativa (gli spazi sono importanti!); attenzione che le parentesi quadrate sono considerate come ultimo comando eseguito
    \item\verb|[[ ... ]]| $\rightarrow$ raggruppamento di espressioni booleani per utilizzare operatori comuni (>, < ...)-
    \item\verb| -f (file) -d (directory)| $\rightarrow$ verificano l'esistenza di un dato file/cartella.
\end{itemize}

\subsection{Cicli}
\begin{itemize}
    \item\verb|if [ ... ]; then ... ; else ...; fi| $\rightarrow$ costrutto if standard
          % Utilizzo = al posto di un pipe per evitare conflitti inutili
    \item\verb=case $var in; a|b) ... ;; c) ... ;; esac= $\rightarrow$ costrutto switch standard
    \item\verb|for (( init ; case; step )); do; ...; done| $\rightarrow$ costrutto for standard
    \item\verb|until [[ ... ]] ; ...; done| $\rightarrow$ while negato
    \item\verb|while [[ ... ]] ; ...; done| $\rightarrow$ while standard
\end{itemize}

\subsection{Funzioni}
\begin{itemize}
    \item\verb|func() { ... }| $\rightarrow$ accedibile come fossero degli script (\verb|func arg1 ... argn|)
\end{itemize}

\subsection{Varie}
\begin{itemize}
    \item\verb|$( ... )| $\rightarrow$ sottoshell che esegue comandi in un processo separato
    \item\verb|BASH_SOURCE[0]| $\rightarrow$ contiene il nome dello script in esecuzione
    \item\verb|exit n| $\rightarrow$ uscita con codice d'errore
    \item\verb|1> 2> ... n>| $\rightarrow$ redirezionamento dei diversi canali sui file, come visto prima (1 = stdout, 2 = stderr); è possibile redirezionare stderr su stdout e viceversa tramite il comando \verb|2>&1|, oppure mettendo tutto su file: \verb|1>output 2>&1|. L'ordine in cui vengono interpretati i redirect sono da destra a sinistra.
\end{itemize}

\section{Make}

\subsection{Introduzione}

Make è un tool utilizzato per automatizzare processi all'interno di sistemi Unix. Viene principalmente usato per automatizzare la compilazione dei file.

I Makefile sono composti da regole, composte da un \textbf{identificativo} (o nome) e da una \textbf{ricetta} (una serie di comandi indentati con una tabulazione \verb|\t| rispetto al nome della ricetta):

\begin{verbatim}
regola:
    echo "Ciao"
\end{verbatim}

I file vengono poi eseguiti tramite il comando \verb|make -f nome_file.makefile|. Notare come i comandi vengono anche stampati su \verb|stdout| oltre a essere eseguiti. Questa funzionalità può essere sfruttata per stampare a video anche i procedimenti che vengono eseguiti dal file, ma può risultare fastidioso: si può quindi inserire una chiocciola \verb|@| che impedisce la stampa del comando.

Il nome del file è opzionale e se non presente viene cercato all'interna della cartella corrente un nome corrispondente a \verb|Makefile|.

In ogni ricetta, ogni riga è trattata singolarmente come un singolo processo, caricando la giusta cartella di lavoro di volta in volta. Bisogna quindi fare attenzione all'uso di \verb|cd|.

All'inizio di ogni regola, si può inoltre specificare una o più \textit{dipendenze} che devono essere rispettate prima di avviare la regola corrispondente. A tal scopo si usa generalmente dare il nome del file che verrà generato alla regola stessa, se la regola ne genera qualcuno:

\begin{verbatim}
file.cc: dipendenza1 dipendenza2... 
    comandi per generare file.cc...
\end{verbatim}

In tutti gli altri casi si parla di \textit{pseudo-regole} ed il nome può essere attribuito di fantasia.

\subsection{Definizione di macro}

All'interno dei makefile si possono definire delle macro, che possono essere utilizzate con una sintassi analoga a bash. Ciò risulta problematico in quanto \verb|$| è interpretato prima da Makefile e poi da Bash.

\begin{verbatim}
MACRO1=Pippo
main:
    @echo Hello $(MACRO1)
\end{verbatim}

Le macro possono inoltre essere sovrascritte al momento dell'avvio di \verb|MAKE| con la medesima sintassi (ma è necessario che la macro stessa sia definita all'interno del file).

Con la sintassi \verb|$(...)| è possibile accedere a una sotto-shell, analoga a quella di Bash, per eseguire comandi all'interno del Makefile stesso. In questo sotto-comando tutti gli \verb|\n| vengono tramutati in spazi.

\section{gcc}

\subsection{Introduzione}

\verb|gcc| è un compilatore multi source/target per compilare i file sorgenti C. Viene utilizzato in combinazione con Make per compilare velocemente più sorgenti.

\subsection{Flag}
\begin{itemize}
    \item\verb|gcc main.c -S| $\rightarrow$ compila in codice Assembly
    \item\verb|gcc main.c -E| $\rightarrow$ esegue solo il preprocessore
    \item\verb|gcc main.c -c| $\rightarrow$ compila senza linkare
    \item\verb|gcc main.c -o| $\rightarrow$ genera i file oggetto binari
    \item\verb|gcc main.c -g| $\rightarrow$ compilazione con mapping per \verb|gdb|
    \item\verb|gcc main.c -DNOME=VAL| $\rightarrow$ compilazione con definizione di macro NOME=VAL
\end{itemize}

\subsection{gdb}

\verb|gdb| è un debugger usato in combinazione con \verb|gcc|. In questo ambiente controllato, possiamo tenere traccia dello stato dell'esecuzione del programma mappando opportunamente le variabili (in quanto i nomi vengono persi durante la compilazione).

Per iniziare, si usa il comando \verb|run| nella shell interattiva che viene presentata da \verb|gdb|.

Punto centrale del debugging è il \textbf{breakpoint}; si tratta di un punto, indicato manualmente con \verb|break *|, che causerà l'interruzione dell'esecuzione del programma una volta raggiunto. A questo punto è possibile o usare \verb|step <count>| e \verb|next <count>| per fare uno o più step generici o principali, oppure interferire volontariamente in maniera più o meno pesante, ad esempio usando \verb|print| per ottenere i valori delle variabili oppure \verb|set variable vname=value| per modificare il valore. Si può infine continuare l'esecuzione con \verb|continue|.

\section{C}

\subsection{Introduzione}

Il lingaggio C è un linguaggio di "basso livello", alla base dei sistemi Unix e dotato di una struttura minimale e ben definita, che velocizza le prestazioni omettendo funzioni di alto livello presenti invece in altri linguaggi.

Prima della compilazione vi è un \textit{pre-processore} il cui compito è interpretare le direttive e gli alias definiti all'inizio del file (tramite l'apposito carattere \verb|#|), generando il cosiddetto file "sorgente direttivo". Le direttive sono varie, seguono le principali:

\begin{itemize}
    \item\verb|#include <lib>| $\rightarrow$ inclusione di codici libreria
    \item\verb|#include "file"| $\rightarrow$ inclusione di file \verb|.h| esterni
    \item\verb|#define NOME TESTO| $\rightarrow$ macro
    \item\verb|#define FUNC(X,Y) (X) (Y)| $\rightarrow$ macro con funzioni
    \item\verb|#if|, \verb|#ifdef NOME|, \verb|#ifndef NOME|, \verb|#else|, \verb|endif| $\rightarrow$ controlli
\end{itemize}

Il linguaggio viene quindi compilato e analizzato una sola volta: prima viene trasformato in codice intermedio (Assembly), poi in file oggetto \verb|.o| e infine linkato ai file libreria e trasformato in linguaggio macchina \verb|.out|.

\subsection{Sintassi}

\begin{itemize}
    \item\verb|int printf(const char *format, …)| $\rightarrow$ stampa con formattazione:\\ \verb|%[flags][width][.precision][length]specifier|; alcuni specifier sono \verb|%c|, \verb|%d|, \verb|%li|, \verb|%s|, rispettivamente \verb|char|, \verb|int|, \verb|long|, \verb|char*|
    \item Si può ovviare alla mancanza dei booleani tramite un apposita macro: \verb|#define BOOL char;| \verb|#define FALSE 0;| \verb|#define TRUE 1;|. Si noti che questa variabile può comunque, analogamente a un char, contenere valori fino a 255; è quindi cura del programmatore utilizzarla in maniera corretta e non confusionaria.
\end{itemize}

\subsection{Organizzazione della memoria}

Data l'immagine del processo in memoria, partendo dall'indirizzo più basso, troviamo:
\begin{itemize}
    \item OS Kernel
    \item Text segment: istruzioni della CPU
    \item Data segment: variabili globali
    \item BSS: variabili non inizializzate
    \item Heap e stack: allocazione dinamica automatica e personalizzata
\end{itemize}

In C, non c'è garbage collection e la memoria allocata dinamicamente va esplicitamente deallocata per evitare fastidiosi memory leak. AL momento dell'allocazione in memoria, distinguiamo tra \textbf{variabili statiche}, corrispondenti alle variabili globali dichiarate all'inizio, \textbf{variabili dinamiche}, ovvero le variabili dichiarate con \verb|new| e con puntatori e che devono essere esplicitamente deallocate, e \textbf{variabili auomatiche}, locali a una funzione.

\subsection{Stringhe, puntatori, tipi}

In C, una \textbf{stringa} è un vettore di caratteri che termina con uno \verb|\0|.

Un \textbf{puntatore} è una variabile che punta a una certa casella di memoria. \verb|int* a| rappresenta un puntatore (non inizializzato) a una variabile di tipo \verb|int|. L'asterisco viene inoltre utilizzato per accedere alla locazione \verb|*a|; \verb|&a| rappresenta invece la locazione di memoria puntata in esadecimale.

Importante è la notazione: infatti il simbolo \verb|*| si lega al nome della variabile e non al tipo, per cui scrivere \verb|int* a, b| definirà una variabile \verb|a| di tipo puntatore a int e \verb|b| di tipo int, e non due puntatori come si potrebbe pensare.

In C è inoltre possibile costruire tipi di dati derivati e rinominarne altri con i costrutti \verb|struct| e \verb|typedef|. La prima permette di creare "tipi aggregati", in maniera analoga a una classe in un linguaggio Object-Oriented; la seconda permette di ridefinire, in maniera analoga a una macro, un certo tipo di dato oppure una struct con un nuovo nome.

\section{Processi}

Per la teoria riguardante i processi, consultare gli appunti di teoria del corso.

La seguente è una lista, non esaustiva, di comandi utili alla gestione dei processi di sistema Unix tramite Bash.

\begin{itemize}
    \item \verb|command&| $\rightarrow$ lancia un processo in background, restituendo il suo PID
    \item \verb|ps| $\rightarrow$ elenca i processi attivi su sistema
    \item \verb|ps -o pid,ppid,pgid,sid,uid,euid| $\rightarrow$ elenca i processi attivi con informazioni extra
\end{itemize}

La seguente è una lista degli identificatori di processo:

\begin{itemize}
    \item \verb|PID| $\rightarrow$ attributo di identificazione univoco per istante temporale
    \item \verb|PPID| $\rightarrow$ id del processo genitore
    \item \verb|PGID| $\rightarrow$ id di un gruppo di processi, che possono collaborare in maniera stretta tra loro; al momento della creazione i figli entrano nel gruppo di un genitore
    \item \verb|SID| $\rightarrow$ insieme di gruppi di processi; alla creazione un processo è associato alla sessione del padre
    \item \verb|RUID, EUID| $\rightarrow$ rispettivamente l'id utente del creatore ed esecutore del processo
\end{itemize}
\end{document}
